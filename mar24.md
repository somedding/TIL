### 2024년 3월 26일
#### RUST

##### 트레잇 이란 무엇인가...  
자바 나 c#의 인터페이스 기능과 매우 유사하다

트레잇 > 다른 구조체의 동작을 공통화 할 수 있다.  

버튼 과 체크박스 가 있을때 서로 구별 하지 않고, 그냥 공통의 동작을 하는 사양을 강제하는 것.

> 타입에 관계 없이 공통적으로 가질 수 있는 동작을 추상화 해 어디에도 쓸수 있게 한다

##### 트레잇 선언 방법
```rust
trait 트레잇명 {
    fn 메서드명1(&self, 인수 1, 인수 2 ...) -> 반환 타입;
    fn 메서드명2(&self, 인수 1, 인수 2 ...) -> 반환 타입;
    ...
}
```

트레잇은 인수, 반환값만을 작성하여 정의한다. 구조체로 구현하기 위해서는 

```rust
impl 트레잇명 for 구조체명 {
    fn 메서드명(&self, 인수 1, 인수 2, ...) -> 반환타입{
        //메서드 처리
    }
}
```

#### 제네릭 복습하기
제네릭은 추상적인 타입을 지정해 다양한 데이터 타입 조작을 가능하게 하는 프로그래밍 기법

제네릭을 이용하면 함수나 메서드의 사용 방법을 통일할 수 있다는 장점 외에도 코드 중복을 줄일 수 있
다.  

`i32` 타입 값을 더하기만 하는 `add_i32` 함수와 `f32` 타입 값을 더하기만 하는 `add_f32` 함수를 만들어야
한다면 다음과 같이 만들 수 있다.  

스트는 타입 체크를 엄격하게 하므로 타입이 다르면 컴파일이 되지 않는다. 하지만 타입이 다르기 때문에 다른 함수를 추가로 만들어야 한다는 건 꽤 불편한 일이다. 게다가 이렇게 비슷한 함수가 여러 개 있다면 실수가 발생할 가능성도 높다  

이럴 때 이용하는 것이 제네릭이다.  

```rust
fn add_i32(a: i32, b: i32) -> i32 {
    a + b
}

fn add_f32(a: f32, b: f32) -> f32 {
    a + b
}

fn main() {
    println!("{}", add_i32(10, 25));
    println!("{}", add_f32(10.0, 25.0));
}
```

위의 함수를 타입을 결정하지 않는 제네릭 함수로 변환하면 다음과 같다.  

```rust
fn add <T: std::ops::Add<Output=T>> (a:T, b:T) -> T {
    a + b
}

fn main() {
    println!("{}", add(10,25));
    println!("{}", add(10.0,25.0));
    println!("{}", add::<i32>(10,25)); //타입을 명시 할 경우
    //println!("{}", add('a','a')); //char 타입은 미구현 이라 에러 발생
}
```

컴파일 하면 f32 이든 i32 이든 add 함수 하나로 계산할 수 있다는 것을 알 수 있다.

제네릭 함수 정의 하는 방법

```
fn 함수명 <T: 트레잇>(인수1： T, 인수2: T, ...) -> 반환값 {
    ...
}
```

`<T:트레잇>` 부분이 중요하다. 제네릭을 사용할때 이 부분이 임의 타입으로 변경된다.

`<T: std::ops::Add<Output=T>>`
에서 `std::ops` 는 오버로드 가능한 연산자 트레잇을 정의한 모듈 이고, `::Add` 트레잇이 덧셈 트레잇 이다.

레잇을 지정하면 그 제네릭은 ‘덧셈을 할 수 있는
타입’을 지정할 수 있다는 의미다.  

비슷한 개념으로 인수 값을 2배로 만드는 제네릭을 만들 수 있다
```rust
// 인수 값을 2배로 만드는 제네릭
fn x2 <T: std::ops::Add<Output=T> + Copy> (n: T) -> T {
    n + n
}
fn main() {
    println!("{}", x2(3));
    println!("{}", x2(3.0f64));
    println!("{}", x2::<u64>(3));
}
```

`Copy` 트레잇을 구현 함으로써 2배로 만들 수 있다. 2개 이상의 트레잇을 지정 할 때에는 '+' 를 이용한다.

제네릭 함수 에서 Where을 사용하는 방법

```rust
fn 함수명 <T>(인수1 : T, 인수2: T, ...) -> 반환값
    where T: 트레잇
    {
        ...
    }
```

위 프로그램을 where을 사용한 제네릭으로 고친 함수  

```rust
fn add <T> (a:T, b:T) -> T
    where T: std::ops::Add<Output=T>
{
    a + b
}

fn main() {
    println!("{}", add(10, 25));
    println!("{}", add(10.0, 25.0));
}
```

구조체에 제네릭을 지정하기

함수 뿐 아니라 구조체를 선언 할 때도 제네릭을 지정 할 수 있다.

구조체 정의를 할 때 붙인 속성
`#[derive(Debug)]`
가 있으므로 구조체의 각 필드 값을 println! 매크
로로 출력할 수 있다.

